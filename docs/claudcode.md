# AIå¯è§åº¦ç›‘æ§å·¥å…· äº§å“éœ€æ±‚æ–‡æ¡£ (PRD)

## æ–‡æ¡£ç‰ˆæœ¬ä¿¡æ¯
- **ç‰ˆæœ¬**: v1.0.0
- **æ–‡æ¡£åˆ›å»º**: 2025-01-23
- **äº§å“è´Ÿè´£äºº**: AIå¯è§åº¦ç›‘æ§å·¥å…· äº§å“å›¢é˜Ÿ
- **å¼€å‘å‘¨æœŸ**: 2å‘¨ (AIå¯è§åº¦ç›‘æ§å¹³å° MVP)
- **é¡¹ç›®ä»£å·**: AIVisibility-MVP
- **ç›®æ ‡åŸŸå**: geoaiwork.com

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 äº§å“æ„¿æ™¯
æ„å»ºä¸€æ¬¾é¢å‘ç½‘ç«™è¿è¥è€…çš„AIå¯è§åº¦ç›‘æ§ä¸ä¼˜åŒ–å·¥å…·ï¼Œå¸®åŠ©ç”¨æˆ·è·Ÿè¸ªå…¶ç½‘ç«™åœ¨AIé—®ç­”å¼•æ“ï¼ˆå¦‚ChatGPTã€Geminiã€Perplexityç­‰ï¼‰ä¸­çš„æ›å…‰æƒ…å†µï¼Œå¹¶æŒ‡å¯¼å…¶æ”¹è¿›å†…å®¹ä»¥æå‡åœ¨AIå›ç­”ä¸­çš„è¢«å¼•ç”¨æœºä¼šã€‚

### 1.2 æ ¸å¿ƒä»·å€¼ä¸»å¼ 
- **AIå¯è§åº¦ç›‘æµ‹ (AEO)**: è·Ÿè¸ªç½‘ç«™åœ¨AIé—®ç­”å¼•æ“ä¸­çš„æ›å…‰å’Œå¼•ç”¨æƒ…å†µ
- **é—®é¢˜ç›‘æ§ç³»ç»Ÿ**: ç®¡ç†å¤šä¸ªå…³é”®é—®é¢˜çš„æŒç»­ç›‘æ§å’ŒçŠ¶æ€è·Ÿè¸ª
- **ç«äº‰å¯¹æ‰‹åˆ†æ**: äº†è§£å“ªäº›ç«äº‰å¯¹æ‰‹åœ¨ç›¸åŒé—®é¢˜ä¸Šè·å¾—AIå¼•ç”¨
- **å†…å®¹ä¼˜åŒ–å»ºè®®**: åŸºäºAIå›ç­”ç»“æœæä¾›å…·ä½“çš„å†…å®¹æ”¹è¿›å»ºè®®

### 1.3 æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
- **æŸ¥è¯¢ç›‘æµ‹å·¥å…·**: æ¨¡æ‹ŸAIæé—®ï¼Œæ£€æŸ¥ç½‘ç«™åœ¨å›ç­”ä¸­çš„å¼•ç”¨çŠ¶æ€
- **é—®é¢˜ç®¡ç†åˆ—è¡¨**: æ‰¹é‡ç›‘æ§å¤šä¸ªé—®é¢˜çš„AIå¯è§åº¦çŠ¶æ€
- **å¯è§åº¦æŠ¥å‘Š**: ç›´è§‚å±•ç¤ºå¼•ç”¨çŠ¶æ€ã€å˜åŒ–è¶‹åŠ¿å’Œç«äº‰å¯¹æ‰‹æƒ…å†µ
- **å†…å®¹ä¼˜åŒ–åŸºç¡€**: æä¾›AIå›ç­”å†…å®¹åˆ†æå’Œæ”¹è¿›å»ºè®®

### 1.4 AIå¯è§åº¦ç›‘æ§å·¥å…· æˆåŠŸæŒ‡æ ‡

- **æŠ€æœ¯KPIs**:
  - AIæŸ¥è¯¢å“åº”æ—¶é—´ < 10ç§’
  - é—®é¢˜ç›‘æ§å‡†ç¡®ç‡ > 95%
  - å¹³å°å¹¶å‘ç”¨æˆ·æ”¯æŒ > 500
  - APIå¯ç”¨æ€§ > 99.5%

- **ä¸šåŠ¡KPIs**:
  - æœˆæ´»è·ƒç”¨æˆ· > 5,000
  - ç”¨æˆ·é—®é¢˜ç›‘æ§åˆ—è¡¨å¹³å‡ > 15ä¸ªé—®é¢˜
  - ä»˜è´¹è½¬åŒ–ç‡ > 10%
  - ç”¨æˆ·ç•™å­˜ç‡ (30å¤©) > 65%

- **äº§å“KPIs**:
  - æ—¥é—®é¢˜æŸ¥è¯¢é‡ > 2,000
  - AIå¼•ç”¨çŠ¶æ€æ£€æµ‹å‡†ç¡®ç‡ > 90%
  - ç”¨æˆ·æ»¡æ„åº¦è¯„åˆ† > 4.3/5
  - ç«äº‰å¯¹æ‰‹è¯†åˆ«å‡†ç¡®åº¦ > 85%

---

## 2. AIå¯è§åº¦ç›‘æ§å·¥å…· å¹³å°æ¶æ„è®¾è®¡

### 2.1 æŠ€æœ¯æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            AIå¯è§åº¦ç›‘æ§å·¥å…·å‰ç«¯ (Next.js 15)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ é¦–é¡µä¸äº§å“ä»‹ç»                                          â”‚
â”‚  â€¢ é—®é¢˜ç›‘æ§ä»ªè¡¨æ¿                                          â”‚
â”‚  â€¢ AIæŸ¥è¯¢ç»“æœå±•ç¤º                                         â”‚
â”‚  â€¢ ç”¨æˆ·è®¤è¯ä¸è´¦æˆ·ç®¡ç†                                       â”‚
â”‚  â€¢ Chromeæ’ä»¶æ¥å£                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               ç›‘æ§å·¥å…· APIå±‚ (Next.js API Routes)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ /api/monitor - é—®é¢˜ç›‘æ§ç®¡ç†                             â”‚
â”‚  â€¢ /api/query - AIæŸ¥è¯¢æ‰§è¡Œ                               â”‚
â”‚  â€¢ /api/analysis - å¼•ç”¨çŠ¶æ€åˆ†æ                           â”‚
â”‚  â€¢ /api/reports - å¯è§åº¦æŠ¥å‘Šç”Ÿæˆ                          â”‚
â”‚  â€¢ /api/competitors - ç«äº‰å¯¹æ‰‹åˆ†æ                        â”‚
â”‚  â€¢ /api/optimization - å†…å®¹ä¼˜åŒ–å»ºè®®                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ç›‘æ§å·¥å…· æ ¸å¿ƒæœåŠ¡å±‚                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ AIæŸ¥è¯¢       â”‚  â”‚ å¼•ç”¨æ£€æµ‹      â”‚  â”‚ é—®é¢˜ç®¡ç†      â”‚  â”‚
â”‚  â”‚ å¼•æ“         â”‚  â”‚ åˆ†æå™¨        â”‚  â”‚ ç³»ç»Ÿ         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ä»»åŠ¡è°ƒåº¦     â”‚  â”‚ æŠ¥å‘Šç”Ÿæˆ      â”‚  â”‚ å†…å®¹ä¼˜åŒ–     â”‚  â”‚
â”‚  â”‚ ç³»ç»Ÿ         â”‚  â”‚ å™¨           â”‚  â”‚ å»ºè®®å™¨       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            æ•°æ®å±‚ (PostgreSQL + DrizzleORM)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ ç”¨æˆ·è´¦æˆ·ä¸è®¢é˜…æ•°æ®                                       â”‚
â”‚  â€¢ é—®é¢˜ç›‘æ§åˆ—è¡¨                                           â”‚
â”‚  â€¢ AIæŸ¥è¯¢ç»“æœå†å²                                         â”‚
â”‚  â€¢ å¼•ç”¨çŠ¶æ€å˜åŒ–è®°å½•                                        â”‚
â”‚  â€¢ ç«äº‰å¯¹æ‰‹åˆ†ææ•°æ®                                        â”‚
â”‚  â€¢ å†…å®¹ä¼˜åŒ–å»ºè®®è®°å½•                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 AIå¯è§åº¦ç›‘æ§å·¥å…· æŠ€æœ¯æ ˆé€‰å‹

| åˆ†ç±» | æŠ€æœ¯é€‰æ‹© | é€‰æ‹©ç†ç”± | ç›‘æ§å·¥å…·åº”ç”¨åœºæ™¯ |
|----------|------------------|------------------|----------------------|
| **å‰ç«¯** | Next.js 15 + TypeScript | SSRæ”¯æŒSEOï¼Œå¼€å‘æ•ˆç‡é«˜ | ç›‘æ§ä»ªè¡¨æ¿ä¸æŠ¥å‘Šå±•ç¤º |
| **æ ·å¼** | Tailwind CSS 4 | ç°ä»£åŒ–è®¾è®¡ï¼Œå“åº”å¼å‹å¥½ | äº§å“ç•Œé¢ä¸è¥é”€é¡µé¢ |
| **åç«¯API** | Next.js API Routes | å…¨æ ˆé›†æˆï¼Œéƒ¨ç½²ç®€åŒ– | AIæŸ¥è¯¢ä¸ç›‘æ§ç®¡ç†APIs |
| **æ•°æ®åº“** | PostgreSQL + DrizzleORM | å…³ç³»å‹æ•°æ®ï¼Œç±»å‹å®‰å…¨ | ç›‘æ§æ•°æ®ä¸ç»“æœå­˜å‚¨ |
| **è®¤è¯** | Clerk | ç°ä»£åŒ–è®¤è¯ï¼Œå¤šç§ç™»å½•æ–¹å¼ | ç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€è®¢é˜…ç®¡ç† |
| **AIé›†æˆ** | OpenAI API + å¤šAIå¼•æ“ | æ”¯æŒå¤šç§AIé—®ç­”å¼•æ“ | ChatGPTã€Perplexityç­‰æŸ¥è¯¢ |
| **ä»»åŠ¡è°ƒåº¦** | Next.js Cron + Bull Queue | å®šæ—¶ç›‘æ§ä»»åŠ¡ | è‡ªåŠ¨åŒ–é—®é¢˜ç›‘æ§æ£€æŸ¥ |
| **ç¼“å­˜** | Redis (å¯é€‰) | å‡å°‘é‡å¤æŸ¥è¯¢ | AIå›ç­”ç»“æœç¼“å­˜ |
| **éƒ¨ç½²** | Vercel | æ— æœåŠ¡å™¨ï¼Œè‡ªåŠ¨æ‰©å®¹ | å¿«é€Ÿå…¨çƒéƒ¨ç½² |
| **ç›‘æ§** | PostHog + Sentry | ç”¨æˆ·è¡Œä¸º+é”™è¯¯ç›‘æ§ | äº§å“ä½¿ç”¨æ•°æ®åˆ†æ |

---

## 3. AIå¯è§åº¦ç›‘æ§å·¥å…· æ ¸å¿ƒåŠŸèƒ½è¯¦ç»†è®¾è®¡

### 3.1 åŠŸèƒ½æ¨¡å—1: æŸ¥è¯¢ç›‘æµ‹å·¥å…·

#### 3.1.1 åŠŸèƒ½æ¦‚è¿°
æ ¸å¿ƒåŠŸèƒ½ï¼Œæ¨¡æ‹ŸAIé—®ç­”å¼•æ“æé—®ï¼Œæ£€æŸ¥æŒ‡å®šç½‘ç«™æ˜¯å¦åœ¨AIå›ç­”ä¸­è¢«å¼•ç”¨æˆ–æåŠã€‚

#### 3.1.2 AIæŸ¥è¯¢ç›‘æµ‹æ¡†æ¶

```typescript
interface AIVisibilityQuery {
  // åŸºç¡€ä¿¡æ¯
  queryId: string;
  targetDomain: string;
  question: string;
  createdAt: Date;

  // AIå¼•æ“è®¾ç½®
  aiEngines: ('chatgpt' | 'perplexity' | 'gemini' | 'bing')[];

  // æŸ¥è¯¢ç»“æœ
  results: AIQueryResult[];

  // å¼•ç”¨çŠ¶æ€
  citationStatus: {
    mentioned: boolean;
    citedSources: string[];
    competitorDomains: string[];
    snippets: string[];
  };
}

interface AIQueryResult {
  engine: string;
  query: string;
  response: string;
  timestamp: Date;

  // åˆ†æç»“æœ
  analysis: {
    targetDomainMentioned: boolean;
    mentionCount: number;
    contextSnippets: string[];
    citationPosition: number | null;
    competitorsMentioned: string[];
    responseQuality: 'low' | 'medium' | 'high';
  };
}

interface MonitoringQuestion {
  id: string;
  userId: string;
  question: string;
  targetDomain: string;
  keywords: string[];

  // ç›‘æ§è®¾ç½®
  frequency: 'daily' | 'weekly' | 'monthly';
  isActive: boolean;
  priority: 'high' | 'medium' | 'low';

  // çŠ¶æ€è·Ÿè¸ª
  currentStatus: 'cited' | 'not_cited' | 'unknown';
  lastChecked: Date;
  statusHistory: StatusChange[];

  // ç«äº‰å¯¹æ‰‹
  competitorsDomains: string[];

  createdAt: Date;
  updatedAt: Date;
}

interface StatusChange {
  timestamp: Date;
  previousStatus: string;
  newStatus: string;
  aiEngine: string;
  changedBy: 'system' | 'user';
}
```

#### 3.1.3 AIæŸ¥è¯¢å¼•æ“å®ç°

```typescript
class AIVisibilityMonitor {
  private aiEngines: Map<string, AIEngine>;

  constructor() {
    this.aiEngines = new Map([
      ['chatgpt', new ChatGPTEngine()],
      ['perplexity', new PerplexityEngine()],
      ['gemini', new GeminiEngine()],
      ['bing', new BingAIEngine()],
    ]);
  }

  async queryAIEngines(
    question: string,
    targetDomain: string,
    engines: string[] = ['chatgpt']
  ): Promise<AIVisibilityQuery> {

    // å¹¶è¡ŒæŸ¥è¯¢å¤šä¸ªAIå¼•æ“
    const queryPromises = engines.map(async (engineName) => {
      const engine = this.aiEngines.get(engineName);
      if (!engine) throw new Error(`Unsupported AI engine: ${engineName}`);

      try {
        const response = await engine.query(question);
        return this.analyzeResponse(response, targetDomain, engineName);
      } catch (error) {
        return this.createErrorResult(engineName, error);
      }
    });

    const results = await Promise.allSettled(queryPromises);
    const successfulResults = results
      .filter(r => r.status === 'fulfilled')
      .map(r => (r as PromiseFulfilledResult<AIQueryResult>).value);

    // åˆ†ææ•´ä½“å¼•ç”¨çŠ¶æ€
    const citationStatus = this.analyzeCitationStatus(successfulResults, targetDomain);

    return {
      queryId: generateQueryId(),
      targetDomain,
      question,
      createdAt: new Date(),
      aiEngines: engines as any[],
      results: successfulResults,
      citationStatus
    };
  }

  private analyzeResponse(
    response: string,
    targetDomain: string,
    engine: string
  ): AIQueryResult {
    // æ£€æµ‹ç›®æ ‡åŸŸåæ˜¯å¦è¢«æåŠ
    const domainRegex = new RegExp(targetDomain.replace('.', '\\.'), 'gi');
    const mentions = response.match(domainRegex) || [];

    // æå–å¼•ç”¨ç‰‡æ®µ
    const snippets = this.extractContextSnippets(response, targetDomain);

    // è¯†åˆ«ç«äº‰å¯¹æ‰‹åŸŸå
    const competitors = this.extractCompetitorDomains(response);

    // è®¡ç®—å¼•ç”¨ä½ç½® (0-100, è¶Šå°è¶Šå¥½)
    const citationPosition = this.calculateCitationPosition(response, targetDomain);

    return {
      engine,
      query: response,
      response,
      timestamp: new Date(),
      analysis: {
        targetDomainMentioned: mentions.length > 0,
        mentionCount: mentions.length,
        contextSnippets: snippets,
        citationPosition,
        competitorsMentioned: competitors,
        responseQuality: this.assessResponseQuality(response)
      }
    };
  }

  private extractContextSnippets(response: string, domain: string): string[] {
    const sentences = response.split(/[.!?]+/);
    return sentences
      .filter(sentence =>
        sentence.toLowerCase().includes(domain.toLowerCase())
      )
      .map(sentence => sentence.trim())
      .slice(0, 3); // é™åˆ¶æœ€å¤š3ä¸ªç‰‡æ®µ
  }

  private extractCompetitorDomains(response: string): string[] {
    // ä½¿ç”¨æ­£åˆ™æå–å¸¸è§åŸŸåæ ¼å¼
    const domainRegex = /https?:\/\/([\w\.-]+\.[a-z]{2,})/gi;
    const matches = [...response.matchAll(domainRegex)];

    return [...new Set(matches.map(match => match[1]))]
      .filter(domain => domain !== 'example.com') // è¿‡æ»¤ç¤ºä¾‹åŸŸå
      .slice(0, 5); // é™åˆ¶æœ€å¤š5ä¸ªç«äº‰å¯¹æ‰‹
  }

  private calculateCitationPosition(response: string, domain: string): number | null {
    const firstMention = response.toLowerCase().indexOf(domain.toLowerCase());
    if (firstMention === -1) return null;

    return Math.round((firstMention / response.length) * 100);
  }

  private analyzeCitationStatus(results: AIQueryResult[], targetDomain: string) {
    const mentioned = results.some(r => r.analysis.targetDomainMentioned);
    const allSnippets = results.flatMap(r => r.analysis.contextSnippets);
    const allCompetitors = [...new Set(results.flatMap(r => r.analysis.competitorsMentioned))];
    const citedSources = results
      .filter(r => r.analysis.targetDomainMentioned)
      .map(r => r.engine);

    return {
      mentioned,
      citedSources,
      competitorDomains: allCompetitors,
      snippets: allSnippets
    };
  }
}

// AIå¼•æ“æŠ½è±¡åŸºç±»
abstract class AIEngine {
  abstract query(question: string): Promise<string>;

  protected async makeRequest(endpoint: string, payload: any): Promise<any> {
    // é€šç”¨è¯·æ±‚å¤„ç†é€»è¾‘
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getApiKey()}`,
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`API request failed: ${response.statusText}`);
    }

    return await response.json();
  }

  protected abstract getApiKey(): string;
}

// ChatGPTå¼•æ“å®ç°
class ChatGPTEngine extends AIEngine {
  protected getApiKey(): string {
    return process.env.OPENAI_API_KEY!;
  }

  async query(question: string): Promise<string> {
    const response = await this.makeRequest('https://api.openai.com/v1/chat/completions', {
      model: 'gpt-4',
      messages: [
        {
          role: 'user',
          content: question
        }
      ],
      max_tokens: 1000,
      temperature: 0.3
    });

    return response.choices[0].message.content;
  }
}

// Perplexityå¼•æ“å®ç°
class PerplexityEngine extends AIEngine {
  protected getApiKey(): string {
    return process.env.PERPLEXITY_API_KEY!;
  }

  async query(question: string): Promise<string> {
    const response = await this.makeRequest('https://api.perplexity.ai/chat/completions', {
      model: 'llama-3.1-sonar-small-128k-online',
      messages: [
        {
          role: 'user',
          content: question
        }
      ]
    });

    return response.choices[0].message.content;
  }
}
```

### 3.2 åŠŸèƒ½æ¨¡å—2: é—®é¢˜ç®¡ç†ä¸ç›‘æ§ç³»ç»Ÿ

#### 3.2.1 å¤šé—®é¢˜ç›‘æ§ç®¡ç†

```typescript
class QuestionMonitorManager {
  async addQuestionToMonitoring(
    userId: string,
    question: string,
    targetDomain: string,
    options: Partial<MonitoringQuestion> = {}
  ): Promise<MonitoringQuestion> {

    // éªŒè¯é—®é¢˜æ˜¯å¦å·²å­˜åœ¨
    const existingQuestion = await this.findExistingQuestion(userId, question, targetDomain);
    if (existingQuestion) {
      throw new Error('This question is already being monitored for this domain');
    }

    // åˆ›å»ºæ–°çš„ç›‘æ§é—®é¢˜
    const monitoringQuestion: MonitoringQuestion = {
      id: generateQuestionId(),
      userId,
      question: question.trim(),
      targetDomain: targetDomain.toLowerCase(),
      keywords: this.extractKeywords(question),
      frequency: options.frequency || 'weekly',
      isActive: true,
      priority: options.priority || 'medium',
      currentStatus: 'unknown',
      lastChecked: new Date(0), // ä»æœªæ£€æŸ¥è¿‡
      statusHistory: [],
      competitorsDomains: [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // ä¿å­˜åˆ°æ•°æ®åº“
    await db.insert(monitoringQuestionsSchema).values(monitoringQuestion);

    // ç«‹å³æ‰§è¡Œç¬¬ä¸€æ¬¡æŸ¥è¯¢
    await this.executeImmediateQuery(monitoringQuestion);

    return monitoringQuestion;
  }

  async executeScheduledMonitoring(frequency: 'daily' | 'weekly' | 'monthly'): Promise<void> {
    // è·å–éœ€è¦æ£€æŸ¥çš„é—®é¢˜
    const questionsToCheck = await this.getQuestionsForScheduledCheck(frequency);

    console.log(`Starting scheduled monitoring for ${questionsToCheck.length} questions`);

    // å¹¶è¡Œå¤„ç†ï¼Œä½†é™åˆ¶å¹¶å‘æ•°é‡ä»¥é¿å…APIé™æµ
    const BATCH_SIZE = 5;
    for (let i = 0; i < questionsToCheck.length; i += BATCH_SIZE) {
      const batch = questionsToCheck.slice(i, i + BATCH_SIZE);

      await Promise.allSettled(
        batch.map(question => this.checkQuestionStatus(question))
      );

      // æ‰¹æ¬¡é—´æš‚åœï¼Œé¿å…APIé™æµ
      if (i + BATCH_SIZE < questionsToCheck.length) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
  }

  private async checkQuestionStatus(question: MonitoringQuestion): Promise<void> {
    try {
      console.log(`Checking question: ${question.question}`);

      // æ‰§è¡ŒAIæŸ¥è¯¢
      const queryResult = await new AIVisibilityMonitor().queryAIEngines(
        question.question,
        question.targetDomain,
        ['chatgpt', 'perplexity'] // é»˜è®¤æŸ¥è¯¢å¼•æ“
      );

      // ç¡®å®šæ–°çŠ¶æ€
      const newStatus = queryResult.citationStatus.mentioned ? 'cited' : 'not_cited';

      // è®°å½•çŠ¶æ€å˜åŒ–
      if (newStatus !== question.currentStatus) {
        const statusChange: StatusChange = {
          timestamp: new Date(),
          previousStatus: question.currentStatus,
          newStatus,
          aiEngine: 'multiple',
          changedBy: 'system'
        };

        question.statusHistory.push(statusChange);

        // å‘é€é€šçŸ¥ç»™ç”¨æˆ·ï¼ˆå¦‚æœçŠ¶æ€ä»not_citedå˜ä¸ºcitedï¼‰
        if (newStatus === 'cited' && question.currentStatus === 'not_cited') {
          await this.notifyUserOfPositiveChange(question, queryResult);
        }
      }

      // æ›´æ–°é—®é¢˜çŠ¶æ€
      question.currentStatus = newStatus;
      question.lastChecked = new Date();
      question.updatedAt = new Date();

      // æ›´æ–°ç«äº‰å¯¹æ‰‹åˆ—è¡¨
      question.competitorsDomains = [
        ...new Set([
          ...question.competitorsDomains,
          ...queryResult.citationStatus.competitorDomains
        ])
      ].slice(0, 10); // é™åˆ¶æœ€å¤š10ä¸ªç«äº‰å¯¹æ‰‹

      // ä¿å­˜åˆ°æ•°æ®åº“
      await db.update(monitoringQuestionsSchema)
        .set({
          currentStatus: question.currentStatus,
          lastChecked: question.lastChecked,
          statusHistory: question.statusHistory,
          competitorsDomains: question.competitorsDomains,
          updatedAt: question.updatedAt
        })
        .where(eq(monitoringQuestionsSchema.id, question.id));

      // ä¿å­˜æŸ¥è¯¢ç»“æœå†å²
      await this.saveQueryResultHistory(question.id, queryResult);

    } catch (error) {
      console.error(`Error checking question ${question.id}:`, error);

      // è®°å½•é”™è¯¯ä½†ä¸å½±å“å…¶ä»–é—®é¢˜çš„æ£€æŸ¥
      await this.logMonitoringError(question.id, error);
    }
  }

  private async notifyUserOfPositiveChange(
    question: MonitoringQuestion,
    queryResult: AIVisibilityQuery
  ): Promise<void> {
    // å‘é€é‚®ä»¶é€šçŸ¥
    const emailContent = {
      to: await this.getUserEmail(question.userId),
      subject: 'ğŸ‰ Your website is now being cited by AI!',
      template: 'positive-citation-change',
      data: {
        question: question.question,
        domain: question.targetDomain,
        citedSources: queryResult.citationStatus.citedSources,
        snippets: queryResult.citationStatus.snippets.slice(0, 2)
      }
    };

    await this.sendNotificationEmail(emailContent);

    // è®°å½•åˆ°ç”¨æˆ·é€šçŸ¥è¡¨
    await db.insert(userNotificationsSchema).values({
      userId: question.userId,
      type: 'positive_citation_change',
      title: 'Website Now Cited by AI',
      content: `Your question "${question.question}" is now being answered with citations to ${question.targetDomain}`,
      isRead: false,
      createdAt: new Date()
    });
  }

  async generateVisibilityReport(
    userId: string,
    timeframe: '7d' | '30d' | '90d' = '30d'
  ): Promise<VisibilityReport> {
    const questions = await this.getUserQuestions(userId);

    const report: VisibilityReport = {
      userId,
      generatedAt: new Date(),
      timeframe,
      summary: {
        totalQuestions: questions.length,
        citedQuestions: questions.filter(q => q.currentStatus === 'cited').length,
        notCitedQuestions: questions.filter(q => q.currentStatus === 'not_cited').length,
        unknownQuestions: questions.filter(q => q.currentStatus === 'unknown').length,
        citationRate: 0,
        trends: await this.calculateTrends(questions, timeframe)
      },
      questionDetails: await Promise.all(
        questions.map(q => this.generateQuestionReport(q, timeframe))
      ),
      competitorAnalysis: await this.generateCompetitorAnalysis(questions),
      recommendations: await this.generateRecommendations(questions)
    };

    // è®¡ç®—å¼•ç”¨ç‡
    const validQuestions = questions.filter(q => q.currentStatus !== 'unknown');
    if (validQuestions.length > 0) {
      report.summary.citationRate = Math.round(
        (report.summary.citedQuestions / validQuestions.length) * 100
      );
    }

    return report;
  }
}

interface VisibilityReport {
  userId: string;
  generatedAt: Date;
  timeframe: string;

  summary: {
    totalQuestions: number;
    citedQuestions: number;
    notCitedQuestions: number;
    unknownQuestions: number;
    citationRate: number; // 0-100
    trends: {
      weeklyChange: number; // +/- percentage
      topPerformingQuestions: string[];
      needsAttentionQuestions: string[];
    };
  };

  questionDetails: QuestionReport[];
  competitorAnalysis: CompetitorAnalysis;
  recommendations: OptimizationRecommendation[];
}

interface QuestionReport {
  questionId: string;
  question: string;
  currentStatus: string;
  statusChanges: number; // çŠ¶æ€å˜åŒ–æ¬¡æ•°
  lastCited: Date | null;
  competitorCount: number;
  aiEnginePerformance: {
    chatgpt: 'cited' | 'not_cited' | 'unknown';
    perplexity: 'cited' | 'not_cited' | 'unknown';
  };
  recommendedActions: string[];
}
```

---

## 4. AIå¯è§åº¦ç›‘æ§å·¥å…· ç”¨æˆ·ç•Œé¢è®¾è®¡

### 4.1 é¦–é¡µä¸è¥é”€é¡µé¢è®¾è®¡

```tsx
// src/app/page.tsx - AIå¯è§åº¦ç›‘æ§å·¥å…·é¦–é¡µ
export default function HomePage() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-100">
      {/* Navigation */}
      <Navigation />

      {/* Hero Section */}
      <HeroSection />

      {/* Features Showcase */}
      <FeaturesSection />

      {/* Live Demo */}
      <LiveDemoSection />

      {/* Customer Testimonials */}
      <TestimonialsSection />

      {/* Pricing */}
      <PricingSection />

      {/* CTA */}
      <CTASection />

      {/* Footer */}
      <Footer />
    </div>
  );
}

function HeroSection() {
  return (
    <section className="relative py-20 px-4">
      <div className="max-w-6xl mx-auto text-center">
        <h1 className="text-5xl md:text-6xl font-bold text-gray-900 mb-6">
          ç›‘æ§æ‚¨çš„ç½‘ç«™åœ¨
          <span className="text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-blue-600">
            {" "}AIæœç´¢å¼•æ“ä¸­çš„å¯è§åº¦
          </span>
        </h1>

        <p className="text-xl text-gray-600 mb-8 max-w-3xl mx-auto">
          è¿½è¸ªæ‚¨çš„ç½‘ç«™åœ¨ChatGPTã€Perplexityã€Geminiç­‰AIé—®ç­”å¼•æ“ä¸­çš„å¼•ç”¨æƒ…å†µã€‚äº†è§£ç«äº‰å¯¹æ‰‹è¡¨ç°ï¼Œè·å–å†…å®¹ä¼˜åŒ–å»ºè®®ï¼Œæå‡AIå¯è§åº¦ã€‚
        </p>

        {/* Question Monitoring Input */}
        <div className="max-w-2xl mx-auto mb-8">
          <QuestionMonitoringInput />
        </div>

        {/* Feature Highlights */}
        <div className="grid md:grid-cols-3 gap-6 max-w-4xl mx-auto">
          <FeatureHighlight
            icon="ğŸ”"
            title="AIæŸ¥è¯¢ç›‘æµ‹"
            description="æ¨¡æ‹ŸAIæé—®ï¼Œæ£€æŸ¥ç½‘ç«™å¼•ç”¨çŠ¶æ€"
          />
          <FeatureHighlight
            icon="ğŸ“Š"
            title="å¤šé—®é¢˜ç›‘æ§"
            description="æ‰¹é‡ç›‘æ§å¤šä¸ªå…³é”®é—®é¢˜çš„AIå¯è§åº¦"
          />
          <FeatureHighlight
            icon="ğŸ†"
            title="ç«äº‰å¯¹æ‰‹åˆ†æ"
            description="äº†è§£ç«äº‰å¯¹æ‰‹çš„AIå¼•ç”¨è¡¨ç°"
          />
        </div>
      </div>
    </section>
  );
}

function QuestionMonitoringInput() {
  const [question, setQuestion] = useState('');
  const [domain, setDomain] = useState('');
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const router = useRouter();

  const handleStartMonitoring = async () => {
    if (!question.trim() || !domain.trim()) {
      toast.error('è¯·è¾“å…¥è¦ç›‘æ§çš„é—®é¢˜å’Œæ‚¨çš„ç½‘ç«™åŸŸå');
      return;
    }

    setIsAnalyzing(true);
    try {
      // åˆ›å»ºç›‘æ§ä»»åŠ¡
      const response = await fetch('/api/monitor', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: question.trim(),
          targetDomain: domain.trim(),
          frequency: 'weekly'
        })
      });

      const data = await response.json();
      if (data.success) {
        // è·³è½¬åˆ°ç›‘æ§ä»ªè¡¨æ¿
        router.push('/dashboard');
        toast.success('ç›‘æ§å·²æ·»åŠ åˆ°æ‚¨çš„åˆ—è¡¨ä¸­');
      } else {
        toast.error('æ·»åŠ ç›‘æ§å¤±è´¥ï¼Œè¯·é‡è¯•');
      }
    } catch (error) {
      toast.error('ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥');
    } finally {
      setIsAnalyzing(false);
    }
  };

  return (
    <div className="bg-white rounded-2xl shadow-lg border p-6">
      <h3 className="text-lg font-semibold mb-4 text-center">å…è´¹å¼€å§‹ç›‘æ§</h3>

      <div className="space-y-4">
        {/* é—®é¢˜è¾“å…¥ */}
        <div>
          <label className="block text-sm font-medium mb-2">è¦ç›‘æ§çš„é—®é¢˜</label>
          <input
            type="text"
            value={question}
            onChange={(e) => setQuestion(e.target.value)}
            placeholder="ä¾‹å¦‚ï¼šæœ€å¥½çš„SEOå·¥å…·æœ‰å“ªäº›ï¼Ÿ"
            className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
            disabled={isAnalyzing}
          />
        </div>

        {/* åŸŸåè¾“å…¥ */}
        <div>
          <label className="block text-sm font-medium mb-2">æ‚¨çš„ç½‘ç«™åŸŸå</label>
          <input
            type="text"
            value={domain}
            onChange={(e) => setDomain(e.target.value)}
            placeholder="ä¾‹å¦‚ï¼šexample.com"
            className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
            disabled={isAnalyzing}
          />
        </div>

        {/* å¼€å§‹ç›‘æ§æŒ‰é’® */}
        <button
          onClick={handleStartMonitoring}
          disabled={isAnalyzing || !question.trim() || !domain.trim()}
          className="w-full py-3 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg font-semibold hover:from-purple-700 hover:to-blue-700 disabled:opacity-50 transition-all"
        >
          {isAnalyzing ? (
            <div className="flex items-center justify-center gap-2">
              <Spinner className="w-5 h-5" />
              æ­£åœ¨åˆ†æ...
            </div>
          ) : (
            'ğŸš€ å¼€å§‹å…è´¹ç›‘æ§'
          )}
        </button>
      </div>
    </div>
  );
}
```

### 4.2 ç›‘æ§ä»ªè¡¨æ¿

```tsx
// src/app/dashboard/page.tsx - ç›‘æ§ä»ªè¡¨æ¿
export default function MonitoringDashboardPage() {
  const [questions, setQuestions] = useState<MonitoringQuestion[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedTimeframe, setSelectedTimeframe] = useState<'7d' | '30d' | '90d'>('30d');

  useEffect(() => {
    loadUserQuestions();
  }, []);

  const loadUserQuestions = async () => {
    try {
      const response = await fetch('/api/monitor/questions');
      const data = await response.json();
      if (data.success) {
        setQuestions(data.questions);
      }
    } catch (error) {
      toast.error('åŠ è½½ç›‘æ§é—®é¢˜å¤±è´¥');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto px-4 py-8">
        {/* é¡µé¢æ ‡é¢˜ */}
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            ğŸ“Š AIå¯è§åº¦ç›‘æ§ä»ªè¡¨æ¿
          </h1>
          <p className="text-gray-600">
            ç›‘æ§æ‚¨ç½‘ç«™åœ¨AIé—®ç­”å¼•æ“ä¸­çš„å¼•ç”¨çŠ¶æ€ï¼Œè·Ÿè¸ªå¯è§åº¦å˜åŒ–è¶‹åŠ¿
          </p>
        </div>

        {/* æ¦‚è§ˆç»Ÿè®¡å¡ç‰‡ */}
        <div className="grid md:grid-cols-4 gap-6 mb-8">
          <OverviewCard
            title="ç›‘æ§é—®é¢˜æ€»æ•°"
            value={questions.length}
            icon="ğŸ”"
            color="blue"
          />
          <OverviewCard
            title="è¢«AIå¼•ç”¨"
            value={questions.filter(q => q.currentStatus === 'cited').length}
            icon="âœ…"
            color="green"
          />
          <OverviewCard
            title="æœªè¢«å¼•ç”¨"
            value={questions.filter(q => q.currentStatus === 'not_cited').length}
            icon="âŒ"
            color="red"
          />
          <OverviewCard
            title="å¼•ç”¨ç‡"
            value={calculateCitationRate(questions)}
            suffix="%"
            icon="ğŸ“ˆ"
            color="purple"
          />
        </div>

        {/* æ“ä½œæ  */}
        <div className="flex justify-between items-center mb-6">
          <div className="flex gap-4">
            <button
              onClick={() => setShowAddQuestionModal(true)}
              className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
            >
              + æ·»åŠ ç›‘æ§é—®é¢˜
            </button>
            <select
              value={selectedTimeframe}
              onChange={(e) => setSelectedTimeframe(e.target.value as any)}
              className="px-3 py-2 border border-gray-300 rounded-lg"
            >
              <option value="7d">è¿‡å»7å¤©</option>
              <option value="30d">è¿‡å»30å¤©</option>
              <option value="90d">è¿‡å»90å¤©</option>
            </select>
          </div>

          <button
            onClick={generateReport}
            className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
          >
            ğŸ“„ ç”ŸæˆæŠ¥å‘Š
          </button>
        </div>

        {/* é—®é¢˜ç›‘æ§åˆ—è¡¨ */}
        {isLoading ? (
          <div className="flex justify-center py-12">
            <Spinner className="w-8 h-8" />
          </div>
        ) : questions.length === 0 ? (
          <EmptyState
            icon="ğŸ”"
            title="æš‚æ— ç›‘æ§é—®é¢˜"
            description="æ·»åŠ æ‚¨æƒ³è¦ç›‘æ§çš„é—®é¢˜ï¼Œå¼€å§‹è·Ÿè¸ªAIå¯è§åº¦"
            actionText="æ·»åŠ ç¬¬ä¸€ä¸ªé—®é¢˜"
            onAction={() => setShowAddQuestionModal(true)}
          />
        ) : (
          <div className="space-y-4">
            {questions.map(question => (
              <QuestionMonitorCard
                key={question.id}
                question={question}
                onUpdate={loadUserQuestions}
                timeframe={selectedTimeframe}
              />
            ))}
          </div>
        )}
      </div>

      {/* æ·»åŠ é—®é¢˜æ¨¡æ€æ¡† */}
      {showAddQuestionModal && (
        <AddQuestionModal
          onClose={() => setShowAddQuestionModal(false)}
          onSuccess={loadUserQuestions}
        />
      )}
    </div>
  );
}

function QuestionMonitorCard({ question, onUpdate, timeframe }: {
  question: MonitoringQuestion;
  onUpdate: () => void;
  timeframe: string;
}) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [queryHistory, setQueryHistory] = useState([]);

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'cited': return 'text-green-600 bg-green-50';
      case 'not_cited': return 'text-red-600 bg-red-50';
      default: return 'text-gray-600 bg-gray-50';
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'cited': return 'âœ…';
      case 'not_cited': return 'âŒ';
      default: return 'â“';
    }
  };

  const loadQueryHistory = async () => {
    if (!isExpanded) return;

    try {
      const response = await fetch(`/api/monitor/questions/${question.id}/history?timeframe=${timeframe}`);
      const data = await response.json();
      if (data.success) {
        setQueryHistory(data.history);
      }
    } catch (error) {
      console.error('åŠ è½½æŸ¥è¯¢å†å²å¤±è´¥:', error);
    }
  };

  useEffect(() => {
    loadQueryHistory();
  }, [isExpanded, timeframe]);

  return (
    <Card className="p-6">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          {/* é—®é¢˜å’ŒçŠ¶æ€ */}
          <div className="flex items-center gap-3 mb-2">
            <h3 className="text-lg font-semibold text-gray-900">
              {question.question}
            </h3>
            <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(question.currentStatus)}`}>
              {getStatusIcon(question.currentStatus)}
              {question.currentStatus === 'cited' ? 'è¢«å¼•ç”¨' :
               question.currentStatus === 'not_cited' ? 'æœªå¼•ç”¨' : 'æœªçŸ¥'}
            </span>
          </div>

          {/* åŸºæœ¬ä¿¡æ¯ */}
          <div className="flex items-center gap-4 text-sm text-gray-600 mb-4">
            <span>ğŸŒ {question.targetDomain}</span>
            <span>ğŸ“… {question.frequency === 'daily' ? 'æ¯æ—¥æ£€æŸ¥' :
                      question.frequency === 'weekly' ? 'æ¯å‘¨æ£€æŸ¥' : 'æ¯æœˆæ£€æŸ¥'}</span>
            <span>ğŸ•’ ä¸Šæ¬¡æ£€æŸ¥: {formatRelativeTime(question.lastChecked)}</span>
            {question.competitorsDomains.length > 0 && (
              <span>ğŸ† {question.competitorsDomains.length} ä¸ªç«äº‰å¯¹æ‰‹</span>
            )}
          </div>

          {/* çŠ¶æ€å†å²ç®€è¦ */}
          <div className="flex items-center gap-2 mb-4">
            <span className="text-sm text-gray-500">æœ€è¿‘å˜åŒ–:</span>
            <div className="flex gap-1">
              {question.statusHistory.slice(-10).map((change, index) => (
                <div
                  key={index}
                  className={`w-3 h-3 rounded-full ${
                    change.newStatus === 'cited' ? 'bg-green-400' :
                    change.newStatus === 'not_cited' ? 'bg-red-400' : 'bg-gray-400'
                  }`}
                  title={`${formatDate(change.timestamp)}: ${change.previousStatus} â†’ ${change.newStatus}`}
                />
              ))}
            </div>
          </div>
        </div>

        {/* æ“ä½œæŒ‰é’® */}
        <div className="flex gap-2">
          <button
            onClick={() => checkQuestionNow(question.id)}
            className="p-2 text-gray-600 hover:text-purple-600 hover:bg-purple-50 rounded-lg transition-colors"
            title="ç«‹å³æ£€æŸ¥"
          >
            ğŸ”„
          </button>
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className="p-2 text-gray-600 hover:text-purple-600 hover:bg-purple-50 rounded-lg transition-colors"
          >
            {isExpanded ? 'ğŸ“–' : 'ğŸ“„'}
          </button>
          <QuestionOptionsDropdown question={question} onUpdate={onUpdate} />
        </div>
      </div>

      {/* å±•å¼€çš„è¯¦ç»†ä¿¡æ¯ */}
      {isExpanded && (
        <div className="mt-6 pt-6 border-t border-gray-200">
          <Tabs defaultValue="history">
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger value="history">æŸ¥è¯¢å†å²</TabsTrigger>
              <TabsTrigger value="competitors">ç«äº‰å¯¹æ‰‹</TabsTrigger>
              <TabsTrigger value="suggestions">ä¼˜åŒ–å»ºè®®</TabsTrigger>
            </TabsList>

            <TabsContent value="history" className="mt-4">
              <QueryHistoryView history={queryHistory} />
            </TabsContent>

            <TabsContent value="competitors" className="mt-4">
              <CompetitorAnalysisView
                competitors={question.competitorsDomains}
                question={question.question}
              />
            </TabsContent>

            <TabsContent value="suggestions" className="mt-4">
              <OptimizationSuggestions
                question={question}
                currentStatus={question.currentStatus}
              />
            </TabsContent>
          </Tabs>
        </div>
      )}
    </Card>
  );
}

function QueryHistoryView({ history }: { history: any[] }) {
  return (
    <div className="space-y-3">
      {history.length === 0 ? (
        <p className="text-gray-500 text-center py-4">æš‚æ— æŸ¥è¯¢å†å²</p>
      ) : (
        history.map((record, index) => (
          <div key={index} className="bg-gray-50 rounded-lg p-3">
            <div className="flex justify-between items-start mb-2">
              <div className="flex items-center gap-2">
                <span className={`px-2 py-1 rounded-full text-xs ${
                  record.mentioned ? 'bg-green-100 text-green-600' : 'bg-red-100 text-red-600'
                }`}>
                  {record.mentioned ? 'âœ… è¢«å¼•ç”¨' : 'âŒ æœªå¼•ç”¨'}
                </span>
                <span className="text-sm text-gray-500">
                  {formatDate(record.timestamp)}
                </span>
              </div>
              <div className="text-xs text-gray-500">
                {record.aiEngines.join(', ')}
              </div>
            </div>

            {record.mentioned && record.snippets.length > 0 && (
              <div className="mt-2">
                <p className="text-xs text-gray-500 mb-1">å¼•ç”¨ç‰‡æ®µ:</p>
                {record.snippets.slice(0, 2).map((snippet, i) => (
                  <blockquote key={i} className="text-sm bg-white p-2 rounded border-l-3 border-green-400 mb-1">
                    "{snippet}"
                  </blockquote>
                ))}
              </div>
            )}

            {record.competitorDomains.length > 0 && (
              <div className="mt-2">
                <p className="text-xs text-gray-500 mb-1">ç«äº‰å¯¹æ‰‹:</p>
                <div className="flex flex-wrap gap-1">
                  {record.competitorDomains.slice(0, 3).map((domain, i) => (
                    <span key={i} className="text-xs bg-orange-100 text-orange-600 px-2 py-1 rounded">
                      {domain}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
        ))
      )}
    </div>
  );
}
```

---

## 5. AIå¯è§åº¦ç›‘æ§å·¥å…· APIè®¾è®¡

### 5.1 RESTful APIè®¾è®¡

#### 5.1.1 é—®é¢˜ç›‘æ§ç®¡ç†API

```typescript
// POST /api/monitor/questions - æ·»åŠ ç›‘æ§é—®é¢˜
interface AddMonitoringQuestionRequest {
  question: string;
  targetDomain: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  priority?: 'high' | 'medium' | 'low';
  keywords?: string[];
}

interface AddMonitoringQuestionResponse {
  success: boolean;
  data?: {
    questionId: string;
    question: MonitoringQuestion;
    initialResult?: AIVisibilityQuery;
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

// å®ç°ç¤ºä¾‹
export async function POST(request: NextRequest) {
  try {
    const { userId } = auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { question, targetDomain, frequency, priority, keywords } = await request.json();

    // éªŒè¯è¾“å…¥
    if (!question?.trim() || !targetDomain?.trim()) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'INVALID_INPUT',
          message: 'Question and domain are required'
        }
      }, { status: 400 });
    }

    // æ£€æŸ¥ç”¨æˆ·é…é¢
    const userQuota = await checkUserQuota(userId);
    if (!userQuota.canAddQuestion) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'QUOTA_EXCEEDED',
          message: 'Monitoring question quota exceeded'
        }
      }, { status: 429 });
    }

    // æ·»åŠ ç›‘æ§é—®é¢˜
    const questionManager = new QuestionMonitorManager();
    const monitoringQuestion = await questionManager.addQuestionToMonitoring(
      userId,
      question.trim(),
      targetDomain.trim(),
      { frequency, priority, keywords }
    );

    // ç«‹å³æ‰§è¡Œç¬¬ä¸€æ¬¡æŸ¥è¯¢
    const aiMonitor = new AIVisibilityMonitor();
    const initialResult = await aiMonitor.queryAIEngines(
      question.trim(),
      targetDomain.trim(),
      ['chatgpt', 'perplexity']
    );

    return NextResponse.json({
      success: true,
      data: {
        questionId: monitoringQuestion.id,
        question: monitoringQuestion,
        initialResult
      }
    });

  } catch (error) {
    console.error('Add monitoring question failed:', error);
    return NextResponse.json({
      success: false,
      error: {
        code: 'OPERATION_FAILED',
        message: 'Failed to add monitoring question'
      }
    }, { status: 500 });
  }
}

// GET /api/monitor/questions - è·å–ç”¨æˆ·çš„ç›‘æ§é—®é¢˜åˆ—è¡¨
export async function GET(request: NextRequest) {
  const { userId } = auth();
  const { searchParams } = new URL(request.url);
  const status = searchParams.get('status'); // 'cited', 'not_cited', 'unknown'
  const priority = searchParams.get('priority');

  try {
    const questions = await db.select()
      .from(monitoringQuestionsSchema)
      .where(
        and(
          eq(monitoringQuestionsSchema.userId, userId),
          status ? eq(monitoringQuestionsSchema.currentStatus, status) : undefined,
          priority ? eq(monitoringQuestionsSchema.priority, priority) : undefined,
          eq(monitoringQuestionsSchema.isActive, true)
        )
      )
      .orderBy(desc(monitoringQuestionsSchema.updatedAt));

    return NextResponse.json({
      success: true,
      data: {
        questions,
        count: questions.length
      }
    });

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: { code: 'FETCH_FAILED', message: 'Failed to fetch questions' }
    }, { status: 500 });
  }
}
```

#### 5.1.2 AIæŸ¥è¯¢æ‰§è¡ŒAPI

```typescript
// POST /api/query/ai-visibility - æ‰§è¡ŒAIå¯è§åº¦æŸ¥è¯¢
interface AIVisibilityQueryRequest {
  question: string;
  targetDomain: string;
  aiEngines?: ('chatgpt' | 'perplexity' | 'gemini' | 'bing')[];
  saveToHistory?: boolean;
  questionId?: string; // å…³è”åˆ°ç›‘æ§é—®é¢˜
}

interface AIVisibilityQueryResponse {
  success: boolean;
  data?: {
    queryId: string;
    query: AIVisibilityQuery;
    analysis: {
      mentioned: boolean;
      citationRate: number;
      competitorCount: number;
      suggestions: string[];
    };
  };
  error?: {
    code: string;
    message: string;
  };
}

export async function POST(request: NextRequest) {
  const { userId } = auth();
  const { question, targetDomain, aiEngines = ['chatgpt'], saveToHistory = true, questionId } = await request.json();

  try {
    // æ‰§è¡ŒAIæŸ¥è¯¢
    const monitor = new AIVisibilityMonitor();
    const result = await monitor.queryAIEngines(question, targetDomain, aiEngines);

    // åˆ†æç»“æœ
    const analysis = {
      mentioned: result.citationStatus.mentioned,
      citationRate: result.citationStatus.mentioned ? 100 : 0,
      competitorCount: result.citationStatus.competitorDomains.length,
      suggestions: generateQuickSuggestions(result)
    };

    // ä¿å­˜æŸ¥è¯¢å†å²
    if (saveToHistory) {
      await db.insert(aiQueryHistorySchema).values({
        userId,
        questionId: questionId || null,
        question,
        targetDomain,
        queryResult: result,
        mentioned: result.citationStatus.mentioned,
        competitorDomains: result.citationStatus.competitorDomains,
        createdAt: new Date()
      });
    }

    return NextResponse.json({
      success: true,
      data: {
        queryId: result.queryId,
        query: result,
        analysis
      }
    });

  } catch (error) {
    console.error('AI visibility query failed:', error);
    return NextResponse.json({
      success: false,
      error: {
        code: 'QUERY_FAILED',
        message: 'AI visibility query failed'
      }
    }, { status: 500 });
  }
}

// POST /api/query/batch - æ‰¹é‡æŸ¥è¯¢å¤šä¸ªé—®é¢˜
interface BatchQueryRequest {
  queries: {
    question: string;
    targetDomain: string;
    questionId?: string;
  }[];
  aiEngines?: string[];
}

export async function POST(request: NextRequest) {
  const { userId } = auth();
  const { queries, aiEngines = ['chatgpt'] } = await request.json();

  // éªŒè¯æ‰¹é‡å¤§å°
  if (queries.length > 10) {
    return NextResponse.json({
      success: false,
      error: { code: 'BATCH_SIZE_EXCEEDED', message: 'Maximum 10 queries per batch' }
    }, { status: 400 });
  }

  const batchId = generateBatchId();

  // å¯åŠ¨åå°å¤„ç†
  processBatchQueries(batchId, queries, aiEngines, userId);

  return NextResponse.json({
    success: true,
    data: {
      batchId,
      status: 'processing',
      estimatedCompletionTime: queries.length * 15, // æ¯ä¸ªæŸ¥è¯¢15ç§’
      trackingUrl: `/api/query/batch/${batchId}/status`
    }
  });
}
```

#### 5.1.3 æŠ¥å‘Šç”ŸæˆAPI

```typescript
// GET /api/reports/visibility - ç”ŸæˆAIå¯è§åº¦æŠ¥å‘Š
interface VisibilityReportRequest {
  timeframe?: '7d' | '30d' | '90d';
  format?: 'json' | 'pdf' | 'csv';
  includeCompetitors?: boolean;
  questionIds?: string[]; // ç‰¹å®šé—®é¢˜çš„æŠ¥å‘Š
}

export async function GET(request: NextRequest) {
  const { userId } = auth();
  const { searchParams } = new URL(request.url);

  const timeframe = (searchParams.get('timeframe') as any) || '30d';
  const format = searchParams.get('format') || 'json';
  const includeCompetitors = searchParams.get('includeCompetitors') === 'true';
  const questionIds = searchParams.get('questionIds')?.split(',');

  try {
    const questionManager = new QuestionMonitorManager();
    const report = await questionManager.generateVisibilityReport(
      userId,
      timeframe
    );

    // å¦‚æœæŒ‡å®šäº†ç‰¹å®šé—®é¢˜ï¼Œè¿‡æ»¤æŠ¥å‘Š
    if (questionIds && questionIds.length > 0) {
      report.questionDetails = report.questionDetails.filter(
        q => questionIds.includes(q.questionId)
      );
      // é‡æ–°è®¡ç®—æ‘˜è¦ç»Ÿè®¡
      report.summary = recalculateSummary(report.questionDetails);
    }

    // æ ¹æ®æ ¼å¼è¿”å›
    switch (format) {
      case 'pdf':
        const pdfBuffer = await generatePDFReport(report);
        return new NextResponse(pdfBuffer, {
          headers: {
            'Content-Type': 'application/pdf',
            'Content-Disposition': `attachment; filename="visibility-report-${timeframe}.pdf"`
          }
        });

      case 'csv':
        const csvContent = generateCSVReport(report);
        return new NextResponse(csvContent, {
          headers: {
            'Content-Type': 'text/csv',
            'Content-Disposition': `attachment; filename="visibility-report-${timeframe}.csv"`
          }
        });

      default:
        return NextResponse.json({
          success: true,
          data: {
            report,
            generatedAt: new Date().toISOString()
          }
        });
    }

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: { code: 'REPORT_GENERATION_FAILED', message: 'Failed to generate report' }
    }, { status: 500 });
  }
}

// POST /api/reports/competitor-analysis - ç«äº‰å¯¹æ‰‹åˆ†ææŠ¥å‘Š
interface CompetitorAnalysisRequest {
  targetDomain: string;
  questions: string[];
  customCompetitors?: string[];
}

export async function POST(request: NextRequest) {
  const { userId } = auth();
  const { targetDomain, questions, customCompetitors } = await request.json();

  try {
    const competitorAnalyzer = new CompetitorVisibilityAnalyzer();
    const analysis = await competitorAnalyzer.analyzeCompetitors(
      targetDomain,
      questions,
      customCompetitors
    );

    // ä¿å­˜åˆ†æç»“æœ
    await db.insert(competitorAnalysisSchema).values({
      userId,
      targetDomain,
      questions,
      competitors: analysis.competitors,
      analysis: analysis,
      createdAt: new Date()
    });

    return NextResponse.json({
      success: true,
      data: analysis
    });

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: { code: 'COMPETITOR_ANALYSIS_FAILED', message: 'Competitor analysis failed' }
    }, { status: 500 });
  }
}
```

### 5.2 æ•°æ®æ¨¡å‹è®¾è®¡

åŸºäºç°æœ‰DrizzleORMæ¨¡å¼ï¼Œæ‰©å±•Schema.tsï¼š

```typescript
// src/models/Schema.tsæ‰©å±•

import {
  integer,
  json,
  pgTable,
  serial,
  text,
  timestamp,
  varchar,
  boolean,
  decimal
} from 'drizzle-orm/pg-core';

// ç›‘æ§é—®é¢˜è¡¨
export const monitoringQuestionsSchema = pgTable('monitoring_questions', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 256 }), // Clerkç”¨æˆ·ID
  question: text('question').notNull(),
  targetDomain: varchar('target_domain', { length: 256 }).notNull(),
  keywords: json('keywords'), // string[]

  // ç›‘æ§è®¾ç½®
  frequency: varchar('frequency', { length: 20 }).default('weekly'), // 'daily', 'weekly', 'monthly'
  isActive: boolean('is_active').default(true),
  priority: varchar('priority', { length: 20 }).default('medium'), // 'high', 'medium', 'low'

  // çŠ¶æ€è·Ÿè¸ª
  currentStatus: varchar('current_status', { length: 20 }).default('unknown'), // 'cited', 'not_cited', 'unknown'
  lastChecked: timestamp('last_checked', { mode: 'date' }),
  statusHistory: json('status_history'), // StatusChange[]

  // ç«äº‰å¯¹æ‰‹
  competitorsDomains: json('competitors_domains'), // string[]

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).defaultNow(),
});

// AIæŸ¥è¯¢å†å²è¡¨
export const aiQueryHistorySchema = pgTable('ai_query_history', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 256 }),
  questionId: integer('question_id').references(() => monitoringQuestionsSchema.id),

  // æŸ¥è¯¢å†…å®¹
  question: text('question').notNull(),
  targetDomain: varchar('target_domain', { length: 256 }).notNull(),

  // æŸ¥è¯¢ç»“æœ
  queryResult: json('query_result'), // AIVisibilityQueryå¯¹è±¡
  mentioned: boolean('mentioned'), // å¿«é€ŸæŸ¥è¯¢ç”¨
  competitorDomains: json('competitor_domains'), // string[]

  // å…ƒæ•°æ®
  aiEngines: json('ai_engines'), // string[]
  processingTime: integer('processing_time'), // æ¯«ç§’

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
});

// æ‰¹é‡æŸ¥è¯¢è¡¨
export const batchQueriesSchema = pgTable('batch_queries', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 256 }),
  batchId: varchar('batch_id', { length: 100 }).unique().notNull(),

  queries: json('queries'), // æŸ¥è¯¢æ•°ç»„
  options: json('options'), // æŸ¥è¯¢é€‰é¡¹

  // çŠ¶æ€è·Ÿè¸ª
  status: varchar('status', { length: 20 }).default('processing'), // 'processing', 'completed', 'failed'
  completedCount: integer('completed_count').default(0),
  totalCount: integer('total_count').notNull(),
  results: json('results'), // ç»“æœæ•°ç»„

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  completedAt: timestamp('completed_at', { mode: 'date' }),
});

// ç«äº‰å¯¹æ‰‹åˆ†æè¡¨
export const competitorAnalysisSchema = pgTable('competitor_analysis', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 256 }),

  targetDomain: varchar('target_domain', { length: 256 }).notNull(),
  questions: json('questions'), // åˆ†æçš„é—®é¢˜æ•°ç»„
  competitors: json('competitors'), // ç«äº‰å¯¹æ‰‹åŸŸåæ•°ç»„

  // åˆ†æç»“æœ
  analysis: json('analysis'), // å®Œæ•´åˆ†æç»“æœ

  // æ‘˜è¦ç»Ÿè®¡
  targetCitationRate: decimal('target_citation_rate', { precision: 5, scale: 2 }),
  avgCompetitorCitationRate: decimal('avg_competitor_citation_rate', { precision: 5, scale: 2 }),
  opportunitiesFound: integer('opportunities_found'),

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
});

// ç”¨æˆ·è®¢é˜…å’Œé…é¢è¡¨
export const userSubscriptionSchema = pgTable('user_subscriptions', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 256 }).unique().notNull(),

  // è®¢é˜…ä¿¡æ¯
  plan: varchar('plan', { length: 50 }).default('free'), // 'free', 'pro', 'enterprise'
  subscriptionStatus: varchar('subscription_status', { length: 20 }).default('active'),

  // é…é¢è®¾ç½®
  questionQuota: integer('question_quota').default(10), // ç›‘æ§é—®é¢˜é…é¢
  queryQuota: integer('query_quota').default(100), // æœˆæŸ¥è¯¢é…é¢
  questionsUsed: integer('questions_used').default(0),
  queriesUsed: integer('queries_used').default(0),
  quotaResetDate: timestamp('quota_reset_date', { mode: 'date' }),

  // æ”¯ä»˜ä¿¡æ¯
  stripeCustomerId: varchar('stripe_customer_id', { length: 256 }),
  stripeSubscriptionId: varchar('stripe_subscription_id', { length: 256 }),

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).defaultNow(),
});

// ç”¨æˆ·é€šçŸ¥è¡¨
export const userNotificationsSchema = pgTable('user_notifications', {
  id: serial('id').primaryKey(),
  userId: varchar('user_id', { length: 256 }),

  type: varchar('type', { length: 50 }), // 'positive_citation_change', 'negative_citation_change', 'quota_warning'
  title: varchar('title', { length: 256 }),
  content: text('content'),

  // çŠ¶æ€
  isRead: boolean('is_read').default(false),
  readAt: timestamp('read_at', { mode: 'date' }),

  // å…³è”æ•°æ®
  relatedQuestionId: integer('related_question_id').references(() => monitoringQuestionsSchema.id),
  metadata: json('metadata'), // é¢å¤–æ•°æ®

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
});

// ç³»ç»Ÿé…ç½®è¡¨ï¼ˆAIå¼•æ“é…ç½®ç­‰ï¼‰
export const systemConfigSchema = pgTable('system_config', {
  id: serial('id').primaryKey(),
  configKey: varchar('config_key', { length: 100 }).unique().notNull(),
  configValue: json('config_value'),
  description: text('description'),
  isActive: boolean('is_active').default(true),

  createdAt: timestamp('created_at', { mode: 'date' }).defaultNow(),
  updatedAt: timestamp('updated_at', { mode: 'date' }).defaultNow(),
});
```

### 5.3 Webhook & å®æ—¶é€šçŸ¥

```typescript
// Webhookå¤„ç†å™¨ï¼Œç”¨äºå¤„ç†AIå¼•æ“çŠ¶æ€å˜åŒ–æˆ–å¤–éƒ¨é›†æˆ
export async function POST(request: NextRequest) {
  const signature = request.headers.get('webhook-signature');
  const payload = await request.text();

  // éªŒè¯webhookç­¾å
  if (!verifyWebhookSignature(signature, payload)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }

  const event = JSON.parse(payload);

  switch (event.type) {
    case 'ai_engine_status_change':
      await handleAIEngineStatusChange(event.data);
      break;

    case 'user_subscription_updated':
      await updateUserSubscription(event.data);
      break;

    case 'scheduled_monitoring_trigger':
      await triggerScheduledMonitoring(event.data);
      break;

    default:
      console.log('Unhandled webhook event:', event.type);
  }

  return NextResponse.json({ success: true });
}

// Server-Sent Events for real-time updates
export async function GET(request: NextRequest) {
  const { userId } = auth();
  const { searchParams } = new URL(request.url);
  const questionId = searchParams.get('questionId');

  // è®¾ç½®SSEå“åº”å¤´
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      // å‘é€åˆå§‹è¿æ¥ç¡®è®¤
      controller.enqueue(encoder.encode(`data: {"type": "connected", "timestamp": "${new Date().toISOString()}"}\n\n`));

      // ç›‘å¬æ•°æ®åº“å˜åŒ–æˆ–ä½¿ç”¨è½®è¯¢
      const interval = setInterval(async () => {
        try {
          const updates = await getRealtimeUpdates(userId, questionId);
          if (updates.length > 0) {
            for (const update of updates) {
              controller.enqueue(encoder.encode(`data: ${JSON.stringify(update)}\n\n`));
            }
          }
        } catch (error) {
          controller.enqueue(encoder.encode(`data: {"type": "error", "message": "Update failed"}\n\n`));
        }
      }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡

      // æ¸…ç†å‡½æ•°
      return () => {
        clearInterval(interval);
      };
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

---

## 6. AIå¯è§åº¦ç›‘æ§å·¥å…· å•†ä¸šæ¨¡å¼ä¸å®šä»·

### 6.1 è®¢é˜…æ–¹æ¡ˆ

```typescript
interface PricingPlan {
  id: string;
  name: string;
  description: string;
  monthlyPrice: number;
  yearlyPrice: number;
  features: PlanFeature[];
  limits: PlanLimits;
  popular?: boolean;
}

interface PlanFeature {
  name: string;
  included: boolean;
  description?: string;
}

interface PlanLimits {
  monitoringQuestions: number;
  monthlyQueries: number;
  aiEngines: string[];
  reportFormats: string[];
  competitorTracking: number;
  support: 'community' | 'email' | 'priority';
  historyRetention: string;
}

const AI_VISIBILITY_PRICING_PLANS: PricingPlan[] = [
  {
    id: 'free',
    name: 'å…è´¹ç‰ˆ',
    description: 'é€‚åˆä¸ªäººç”¨æˆ·å’Œå°å‹ç½‘ç«™è¿è¥è€…',
    monthlyPrice: 0,
    yearlyPrice: 0,
    features: [
      { name: 'é—®é¢˜ç›‘æ§', included: true, description: 'æœ€å¤šç›‘æ§3ä¸ªé—®é¢˜' },
      { name: 'AIæŸ¥è¯¢æ£€æµ‹', included: true, description: 'ä»…ChatGPTå¼•æ“' },
      { name: 'åŸºç¡€å¯è§åº¦æŠ¥å‘Š', included: true },
      { name: 'ç«äº‰å¯¹æ‰‹åˆ†æ', included: false },
      { name: 'å†å²æ•°æ®åˆ†æ', included: false },
      { name: 'å†…å®¹ä¼˜åŒ–å»ºè®®', included: false },
      { name: 'é‚®ä»¶é€šçŸ¥', included: false },
      { name: 'APIè®¿é—®', included: false }
    ],
    limits: {
      monitoringQuestions: 3,
      monthlyQueries: 30,
      aiEngines: ['chatgpt'],
      reportFormats: ['åœ¨çº¿æŸ¥çœ‹'],
      competitorTracking: 0,
      support: 'community',
      historyRetention: '7å¤©'
    }
  },
  {
    id: 'pro',
    name: 'ä¸“ä¸šç‰ˆ',
    description: 'é€‚åˆå†…å®¹è¥é”€äººå‘˜å’ŒSEOä¸“ä¸šäººå£«',
    monthlyPrice: 39,
    yearlyPrice: 390, // èŠ‚çœ2ä¸ªæœˆ
    popular: true,
    features: [
      { name: 'å…è´¹ç‰ˆæ‰€æœ‰åŠŸèƒ½', included: true },
      { name: 'æ‰©å±•é—®é¢˜ç›‘æ§', included: true, description: 'æœ€å¤š50ä¸ªé—®é¢˜' },
      { name: 'å¤šAIå¼•æ“æ”¯æŒ', included: true, description: 'ChatGPTã€Perplexityã€Gemini' },
      { name: 'ç«äº‰å¯¹æ‰‹åˆ†æ', included: true, description: 'æœ€å¤š10ä¸ªç«äº‰å¯¹æ‰‹' },
      { name: 'å†å²è¶‹åŠ¿åˆ†æ', included: true },
      { name: 'AIé©±åŠ¨ä¼˜åŒ–å»ºè®®', included: true },
      { name: 'é‚®ä»¶å’Œæ¨é€é€šçŸ¥', included: true },
      { name: 'é«˜çº§æŠ¥å‘Šå¯¼å‡º', included: true, description: 'PDFã€CSVæ ¼å¼' }
    ],
    limits: {
      monitoringQuestions: 50,
      monthlyQueries: 1500,
      aiEngines: ['chatgpt', 'perplexity', 'gemini'],
      reportFormats: ['åœ¨çº¿æŸ¥çœ‹', 'PDF', 'CSV'],
      competitorTracking: 10,
      support: 'email',
      historyRetention: '90å¤©'
    }
  },
  {
    id: 'enterprise',
    name: 'ä¼ä¸šç‰ˆ',
    description: 'é€‚åˆä»£ç†å…¬å¸å’Œå¤§å‹ç»„ç»‡',
    monthlyPrice: 99,
    yearlyPrice: 990,
    features: [
      { name: 'ä¸“ä¸šç‰ˆæ‰€æœ‰åŠŸèƒ½', included: true },
      { name: 'æ— é™é—®é¢˜ç›‘æ§', included: true },
      { name: 'æ‰€æœ‰AIå¼•æ“æ”¯æŒ', included: true, description: 'åŒ…æ‹¬Bingã€Claudeç­‰' },
      { name: 'æ— é™ç«äº‰å¯¹æ‰‹è·Ÿè¸ª', included: true },
      { name: 'APIè®¿é—®', included: true, description: 'é«˜é¢‘ç‡é™åˆ¶' },
      { name: 'ç™½æ ‡æŠ¥å‘Š', included: true },
      { name: 'å›¢é˜Ÿåä½œ', included: true, description: 'æœ€å¤š10ä¸ªç”¨æˆ·' },
      { name: 'ä¼˜å…ˆå®¢æœæ”¯æŒ', included: true },
      { name: 'Chromeæ’ä»¶', included: true }
    ],
    limits: {
      monitoringQuestions: -1, // æ— é™åˆ¶
      monthlyQueries: 10000,
      aiEngines: ['chatgpt', 'perplexity', 'gemini', 'bing', 'claude'],
      reportFormats: ['åœ¨çº¿æŸ¥çœ‹', 'PDF', 'CSV', 'JSON API'],
      competitorTracking: -1, // æ— é™åˆ¶
      support: 'priority',
      historyRetention: '1å¹´'
    }
  }
];
```

### 6.2 åŠŸèƒ½å¯¹æ¯”è¡¨

| åŠŸèƒ½ç‰¹æ€§ | å…è´¹ç‰ˆ | ä¸“ä¸šç‰ˆ | ä¼ä¸šç‰ˆ |
|----------|----------|----------|----------|
| **ç›‘æ§é—®é¢˜æ•°é‡** | 3ä¸ª | 50ä¸ª | æ— é™åˆ¶ |
| **æœˆæŸ¥è¯¢é…é¢** | 30æ¬¡ | 1500æ¬¡ | 10000æ¬¡ |
| **AIå¼•æ“æ”¯æŒ** | ChatGPT | ChatGPT + Perplexity + Gemini | æ‰€æœ‰å¼•æ“ |
| **ç›‘æ§é¢‘ç‡** | ä»…æ‰‹åŠ¨ | æ¯å‘¨è‡ªåŠ¨ | æ¯æ—¥è‡ªåŠ¨ |
| **ç«äº‰å¯¹æ‰‹åˆ†æ** | âŒ | 10ä¸ª | æ— é™åˆ¶ |
| **å†å²æ•°æ®** | 7å¤© | 90å¤© | 1å¹´ |
| **æŠ¥å‘Šå¯¼å‡º** | åœ¨çº¿æŸ¥çœ‹ | PDF/CSV | ç™½æ ‡æŠ¥å‘Š |
| **é‚®ä»¶é€šçŸ¥** | âŒ | âœ… | âœ… |
| **APIè®¿é—®** | âŒ | âŒ | âœ… |
| **Chromeæ’ä»¶** | âŒ | âŒ | âœ… |
| **å›¢é˜Ÿåä½œ** | âŒ | âŒ | 10ç”¨æˆ· |
| **å®¢æˆ·æ”¯æŒ** | ç¤¾åŒº | é‚®ä»¶ | ä¼˜å…ˆæ”¯æŒ |

### 6.3 æ”¶å…¥æ¨¡å¼ç­–ç•¥

```typescript
interface AIVisibilityRevenueStrategy {
  primaryModel: 'freemium_saas';

  revenueStreams: {
    subscriptions: {
      target: '85%'; // 85%çš„æ”¶å…¥æ¥è‡ªè®¢é˜…
      plans: ['pro', 'enterprise'];
      averageLifetimeValue: {
        pro: 468; // $39 Ã— 12ä¸ªæœˆ
        enterprise: 1188; // $99 Ã— 12ä¸ªæœˆ
      };
    };

    payPerQuery: {
      target: '10%'; // 10%æ¥è‡ªè¶…é‡æŸ¥è¯¢è´¹
      pricing: {
        extraQueries: 1; // æ¯æ¬¡é¢å¤–æŸ¥è¯¢$1
        queryPacks: 25; // 50æ¬¡æŸ¥è¯¢åŒ…$25
      };
    };

    apiAccess: {
      target: '3%'; // 3%æ¥è‡ªAPIä½¿ç”¨
      pricing: {
        perRequest: 0.05; // æ¯æ¬¡APIè¯·æ±‚$0.05
        monthlyApiPlan: 29; // $29/æœˆ1000æ¬¡è¯·æ±‚
      };
    };

    whiteLabel: {
      target: '2%'; // 2%æ¥è‡ªç™½æ ‡æœåŠ¡
      pricing: {
        setupFee: 500; // ä¸€æ¬¡æ€§è®¾ç½®è´¹ç”¨
        monthlyFee: 199; // æœˆè´¹
      };
    };
  };

  customerAcquisition: {
    freeToProConversion: '18%'; // ç›®æ ‡18%å…è´¹è½¬ä¸“ä¸šç‰ˆ
    proToEnterpriseUpgrade: '8%'; // 8%ä¸“ä¸šç‰ˆå‡ä¼ä¸šç‰ˆ
    averageTimeToConvert: '21 days';
    churnRate: {
      monthly: '6%';
      yearly: '12%';
    };
  };

  growthStrategy: {
    viralCoefficient: 0.3; // æ¯ä¸ªç”¨æˆ·å¹³å‡æ¨è0.3ä¸ªæ–°ç”¨æˆ·
    contentMarketing: '40% of acquisition';
    paidAdvertising: '35% of acquisition';
    referralProgram: '15% of acquisition';
    partnerChannels: '10% of acquisition';
  };
}
```

### 6.4 å®šä»·å¿ƒç†å­¦ä¸ä¼˜åŒ–

```typescript
interface PricingOptimization {
  psychologicalPricing: {
    // ä½¿ç”¨$39è€Œä¸æ˜¯$40ï¼Œ$99è€Œä¸æ˜¯$100
    endDigits: [9]; // ä»¥9ç»“å°¾
    avoidance: [0, 5]; // é¿å…æ•´æ•°å’Œä»¥5ç»“å°¾
  };

  valueAnchoring: {
    // çªå‡ºä¸“ä¸šç‰ˆçš„æ€§ä»·æ¯”
    popularPlan: 'pro';
    savingsHighlight: 'èŠ‚çœ2ä¸ªæœˆè´¹ç”¨';
    featureComparison: 'æ¯”å…è´¹ç‰ˆå¤šè·å¾—50å€ç›‘æ§èƒ½åŠ›';
  };

  planPositioning: {
    free: {
      role: 'lead_magnet';
      goal: 'demonstrate_value';
      limitationsDesign: 'encourage_upgrade';
    };
    pro: {
      role: 'primary_conversion_target';
      goal: 'maximize_revenue_per_user';
      features: 'meet_80_percent_needs';
    };
    enterprise: {
      role: 'premium_anchor';
      goal: 'justify_pro_pricing';
      features: 'enterprise_requirements';
    };
  };

  timeBasedIncentives: {
    yearlyDiscount: 0.17; // 17% discount for yearly
    seasonalPromotions: [
      { month: 11, discount: 0.25, name: 'Black Friday' },
      { month: 12, discount: 0.20, name: 'Year End' },
      { month: 1, discount: 0.15, name: 'New Year' }
    ];
    limitedTimeOffers: {
      newUserDiscount: 0.30; // 30% off first 3 months
      upgradeIncentive: 0.20; // 20% off when upgrading
    };
  };
}
```

### 6.5 è®¢é˜…ç®¡ç†ä¸è®¡è´¹

```typescript
// Stripeé›†æˆç¤ºä¾‹
class SubscriptionManager {
  async createSubscription(userId: string, planId: string, billingCycle: 'monthly' | 'yearly') {
    const user = await this.getUser(userId);

    // åˆ›å»ºæˆ–è·å–Stripeå®¢æˆ·
    let stripeCustomer = await stripe.customers.retrieve(user.stripeCustomerId);
    if (!stripeCustomer) {
      stripeCustomer = await stripe.customers.create({
        email: user.email,
        name: user.fullName,
        metadata: { userId }
      });

      // ä¿å­˜å®¢æˆ·ID
      await this.updateUser(userId, { stripeCustomerId: stripeCustomer.id });
    }

    // è·å–ä»·æ ¼ID
    const priceId = this.getPriceId(planId, billingCycle);

    // åˆ›å»ºè®¢é˜…
    const subscription = await stripe.subscriptions.create({
      customer: stripeCustomer.id,
      items: [{ price: priceId }],
      billing_cycle_anchor: this.getNextBillingDate(),
      metadata: {
        userId,
        planId,
        billingCycle
      }
    });

    // æ›´æ–°ç”¨æˆ·è®¢é˜…ä¿¡æ¯
    await db.update(userSubscriptionSchema)
      .set({
        plan: planId,
        subscriptionStatus: 'active',
        stripeSubscriptionId: subscription.id,
        quotaResetDate: new Date(subscription.current_period_end * 1000),
        updatedAt: new Date()
      })
      .where(eq(userSubscriptionSchema.userId, userId));

    return subscription;
  }

  async handleQuotaUsage(userId: string, queryCount: number = 1) {
    const subscription = await this.getUserSubscription(userId);

    // æ£€æŸ¥æ˜¯å¦è¶…å‡ºé…é¢
    if (subscription.queriesUsed + queryCount > subscription.queryQuota) {
      // æä¾›è¶…é‡è®¡è´¹é€‰é¡¹
      const overage = (subscription.queriesUsed + queryCount) - subscription.queryQuota;
      const overageFee = overage * 1; // $1 per extra query

      // åˆ›å»ºä¸€æ¬¡æ€§è´¹ç”¨
      await stripe.invoiceItems.create({
        customer: subscription.stripeCustomerId,
        amount: overageFee * 100, // cents
        currency: 'usd',
        description: `é¢å¤–æŸ¥è¯¢è´¹ç”¨: ${overage}æ¬¡æŸ¥è¯¢`
      });

      throw new Error(`QUOTA_EXCEEDED:éœ€è¦æ”¯ä»˜é¢å¤–è´¹ç”¨$${overageFee}`);
    }

    // æ›´æ–°ä½¿ç”¨é‡
    await db.update(userSubscriptionSchema)
      .set({
        queriesUsed: subscription.queriesUsed + queryCount,
        updatedAt: new Date()
      })
      .where(eq(userSubscriptionSchema.userId, userId));
  }

  async resetMonthlyQuotas() {
    // é‡ç½®æ‰€æœ‰ç”¨æˆ·çš„æœˆåº¦é…é¢
    await db.update(userSubscriptionSchema)
      .set({
        queriesUsed: 0,
        quotaResetDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30å¤©å
        updatedAt: new Date()
      })
      .where(lte(userSubscriptionSchema.quotaResetDate, new Date()));
  }
}
```

### 6.6 å¢é•¿ç­–ç•¥

```typescript
interface GrowthStrategy {
  acquisition: {
    contentMarketing: {
      blogPosts: [
        'AIæœç´¢å¼•æ“ä¼˜åŒ–å®Œæ•´æŒ‡å—',
        'å¦‚ä½•è®©ChatGPTå¼•ç”¨ä½ çš„ç½‘ç«™',
        '2024å¹´AIå¯è§åº¦ç›‘æ§æœ€ä½³å®è·µ',
        'Perplexity vs ChatGPT: å†…å®¹å¼•ç”¨å¯¹æ¯”åˆ†æ'
      ];
      seoKeywords: [
        'AIæœç´¢å¼•æ“ä¼˜åŒ–',
        'ChatGPT SEO',
        'AIå¯è§åº¦ç›‘æ§',
        'Perplexityä¼˜åŒ–'
      ];
    };

    partnerProgram: {
      commission: 0.3; // 30%ä½£é‡‘
      cookieDuration: '90å¤©';
      targetPartners: [
        'SEOå·¥å…·å¼€å‘è€…',
        'æ•°å­—è¥é”€é¡¾é—®',
        'AIå†…å®¹åˆ›ä½œè€…',
        'æŠ€æœ¯åšå®¢ä¸»'
      ];
    };

    freeTrialOptimization: {
      trialLength: '14å¤©';
      onboardingSequence: [
        'æ³¨å†Œå³å¯è·å¾—3ä¸ªç›‘æ§é—®é¢˜',
        'ç¬¬1å¤©ï¼šæ·»åŠ ç¬¬ä¸€ä¸ªç›‘æ§é—®é¢˜',
        'ç¬¬3å¤©ï¼šæŸ¥çœ‹é¦–æ¬¡AIæŸ¥è¯¢ç»“æœ',
        'ç¬¬7å¤©ï¼šåˆ†æç«äº‰å¯¹æ‰‹è¡¨ç°',
        'ç¬¬12å¤©ï¼šå‡çº§æé†’å’Œä¼˜æƒ '
      ];
    };
  };

  retention: {
    onboardingFlow: {
      step1: 'è®¾ç½®ç¬¬ä¸€ä¸ªç›‘æ§é—®é¢˜',
      step2: 'æŸ¥çœ‹AIæŸ¥è¯¢ç»“æœ',
      step3: 'äº†è§£ç«äº‰å¯¹æ‰‹æƒ…å†µ',
      step4: 'è®¾ç½®é€šçŸ¥åå¥½',
      step5: 'æ¢ç´¢é«˜çº§åŠŸèƒ½'
    };

    engagementFeatures: {
      weeklyDigest: 'AIå¯è§åº¦å‘¨æŠ¥',
      trendAlerts: 'AIå¼•ç”¨è¶‹åŠ¿å˜åŒ–æé†’',
      competitorUpdates: 'ç«äº‰å¯¹æ‰‹æ–°åŠ¨å‘é€šçŸ¥',
      improvementSuggestions: 'ä¸ªæ€§åŒ–ä¼˜åŒ–å»ºè®®'
    };

    churnPrevention: {
      exitIntentPopup: 'ç‰¹åˆ«ä¼˜æƒ æŒ½ç•™',
      usageAnalytics: 'è¯†åˆ«ä½¿ç”¨é‡ä¸‹é™ç”¨æˆ·',
      proactiveSupport: 'ä¸»åŠ¨å®¢æˆ·æˆåŠŸæœåŠ¡',
      featureEducation: 'ä½¿ç”¨æŠ€å·§å’Œæœ€ä½³å®è·µ'
    };
  };

  monetization: {
    upsellTriggers: [
      'æ¥è¿‘é—®é¢˜é…é¢é™åˆ¶æ—¶',
      'é¢‘ç¹ä½¿ç”¨ç«äº‰å¯¹æ‰‹åˆ†æåŠŸèƒ½',
      'å¤šæ¬¡å¯¼å‡ºæŠ¥å‘Šéœ€æ±‚',
      'è¯¢é—®APIè®¿é—®åŠŸèƒ½'
    ];

    addOnServices: {
      customReports: '$29/æœˆ - å®šåˆ¶æŠ¥å‘ŠæœåŠ¡',
      dataIntegration: '$49/æœˆ - ç¬¬ä¸‰æ–¹æ•°æ®æ•´åˆ',
      advancedAnalytics: '$19/æœˆ - é«˜çº§åˆ†æåŠŸèƒ½',
      prioritySupport: '$15/æœˆ - ä¼˜å…ˆæŠ€æœ¯æ”¯æŒ'
    };
  };
}
```

---

## 7. å®æ–½æ—¶é—´çº¿ä¸é‡Œç¨‹ç¢‘

### 7.1 GeoAIWork.com 14å¤©å¼€å‘è®¡åˆ’

| å¤©æ•° | ä¸»è¦ä»»åŠ¡ | å…·ä½“å†…å®¹ | éªŒæ”¶æ ‡å‡† |
|-----|-----------|------------------|---------------------|
| **ç¬¬1å¤©** | é¡¹ç›®åˆå§‹åŒ– | â€¢ åˆ›å»ºNext.jsé¡¹ç›®<br>â€¢ é…ç½®TypeScriptã€Tailwind<br>â€¢ è®¾ç½®åŸºç¡€ç›®å½•ç»“æ„ | é¡¹ç›®è¿è¡Œï¼Œå¼€å‘ç¯å¢ƒå®Œå¤‡ |
| **ç¬¬2å¤©** | æ•°æ®åº“ä¸è®¤è¯è®¾ç½® | â€¢ è®¾ç½®PostgreSQL + DrizzleORM<br>â€¢ é…ç½®Clerkè®¤è¯<br>â€¢ åˆ›å»ºåŸºç¡€æ•°æ®æ¨¡å‹ | è®¤è¯å·¥ä½œï¼Œæ•°æ®åº“è¿æ¥ |
| **ç¬¬3å¤©** | æ ¸å¿ƒåˆ†æå¼•æ“ | â€¢ å®ç°URLéªŒè¯<br>â€¢ å¼€å‘ç½‘é¡µæŠ“å–åŠŸèƒ½<br>â€¢ åŸºç¡€HTMLè§£æåŠŸèƒ½ | èƒ½å¤ŸæŠ“å–å’Œè§£æåŸºç¡€ç½‘ç«™å†…å®¹ |
| **ç¬¬4å¤©** | GEOè¯„åˆ†ç®—æ³• | â€¢ å®ç°5å¤§ç±»è¯„åˆ†<br>â€¢ AIå°±ç»ªåº¦æ£€æµ‹<br>â€¢ ç»“æ„åŒ–æ•°æ®è¯†åˆ« | èƒ½å¤Ÿä¸ºç½‘ç«™ç”ŸæˆGEOè¯„åˆ† |
| **ç¬¬5å¤©** | å†…å®¹ä¼˜åŒ–å™¨ | â€¢ FAQæ£€æµ‹å’Œæå–<br>â€¢ å†…å®¹ç»“æ„åˆ†æ<br>â€¢ AIå‹å¥½åº¦å†…å®¹è¯„åˆ† | èƒ½å¤Ÿè¯†åˆ«ä¼˜åŒ–æœºä¼š |
| **ç¬¬6å¤©** | ç»“æ„åŒ–æ•°æ®ç”Ÿæˆå™¨ | â€¢ FAQ JSON-LDç”Ÿæˆ<br>â€¢ LLM.txtæ–‡ä»¶åˆ›å»º<br>â€¢ AIæ•°æ®é›†ç”Ÿæˆ | ç”Ÿæˆæ ‡å‡†ä¼˜åŒ–æ–‡ä»¶ |
| **ç¬¬7å¤©** | AIé›†æˆ | â€¢ OpenAI APIé›†æˆ<br>â€¢ å†…å®¹å»ºè®®ç”Ÿæˆ<br>â€¢ å›é€€ç®—æ³• | AIé©±åŠ¨å»ºè®®å·¥ä½œ |
| **ç¬¬8å¤©** | ç«äº‰å¯¹æ‰‹åˆ†æ | â€¢ ç«äº‰å¯¹æ‰‹è¯†åˆ«<br>â€¢ å¯¹æ¯”åˆ†æ<br>â€¢ æœºä¼šè¯†åˆ« | èƒ½å¤Ÿåˆ†æå’Œå¯¹æ¯”ç«äº‰å¯¹æ‰‹ |
| **ç¬¬9å¤©** | å‰ç«¯ - è¥é”€é¡µé¢ | â€¢ é¦–é¡µheroåŒºåŸŸ<br>â€¢ å®šä»·é¡µé¢<br>â€¢ åŠŸèƒ½å±•ç¤º | è¥é”€ç«™ç‚¹å®Œæˆå¹¶å“åº”å¼ |
| **ç¬¬10å¤©** | å‰ç«¯ - åˆ†æç•Œé¢ | â€¢ åˆ†æå·¥ä½œå°UI<br>â€¢ ç»“æœå±•ç¤ºç»„ä»¶<br>â€¢ æ–‡ä»¶ä¸‹è½½åŠŸèƒ½ | åˆ†æç•Œé¢å®Œå…¨åŠŸèƒ½ |
| **ç¬¬11å¤©** | APIå¼€å‘ | â€¢ RESTful APIç«¯ç‚¹<br>â€¢ è®¤è¯ä¸­é—´ä»¶<br>â€¢ é™æµ | APIsä¸å‰ç«¯æ­£ç¡®å·¥ä½œ |
| **ç¬¬12å¤©** | ç”¨æˆ·ä»ªè¡¨æ¿ | â€¢ ç”¨æˆ·è´¦æˆ·ç®¡ç†<br>â€¢ åˆ†æå†å²<br>â€¢ è®¢é˜…å¤„ç† | ç”¨æˆ·ä½“éªŒæµç¨‹å®Œæ•´ |
| **ç¬¬13å¤©** | æµ‹è¯•ä¸ä¼˜åŒ– | â€¢ ç«¯åˆ°ç«¯æµ‹è¯•<br>â€¢ æ€§èƒ½ä¼˜åŒ–<br>â€¢ Bugä¿®å¤ | æ‰€æœ‰åŠŸèƒ½æµ‹è¯•å¹¶æ€§èƒ½è‰¯å¥½ |
| **ç¬¬14å¤©** | éƒ¨ç½²ä¸å¯åŠ¨ | â€¢ ç”Ÿäº§éƒ¨ç½²<br>â€¢ åŸŸåé…ç½®<br>â€¢ å¯åŠ¨å‡†å¤‡ | GeoAIWork.comä¸Šçº¿å¹¶åŠŸèƒ½æ­£å¸¸ |

### 7.2 æ—¥å¸¸ä»»åŠ¡åˆ†è§£

#### ç¬¬1-2å¤©: åŸºç¡€è®¾ç½®
```bash
# ç¬¬1å¤©
npx create-next-app@latest geoaiwork --typescript --tailwind --app
cd geoaiwork
npm install @clerk/nextjs drizzle-orm postgres playwright cheerio openai

# åˆ›å»ºç›®å½•ç»“æ„
mkdir -p src/{components,lib,types,utils}
mkdir -p src/app/api/{analyze,competitors,generate}
mkdir -p tests/{unit,integration,e2e}

# ç¬¬2å¤©
# è®¾ç½®è®¤è¯å’Œæ•°æ®åº“
npm install drizzle-kit @types/pg
# é…ç½®Clerkè®¤è¯
# è®¾ç½®PostgreSQLæ•°æ®åº“æ¶æ„
```

#### ç¬¬3-5å¤©: æ ¸å¿ƒåˆ†æå¼•æ“
```typescript
// src/lib/analyzers/GeoAnalyzer.ts
export class GeoAIWorkAnalyzer {
  async analyzeWebsite(url: string): Promise<GeoAIWorkAnalysis> {
    // ç½‘ç«™åˆ†æé€»è¾‘å®ç°
  }
}

// src/lib/scrapers/WebScraper.ts
export class WebScraper {
  async scrapeWebsite(url: string): Promise<PageData> {
    // ç½‘é¡µæŠ“å–é€»è¾‘å®ç°
  }
}

// src/lib/scoring/ScoreCalculator.ts
export class ScoreCalculator {
  calculateGeoScore(pageData: PageData): ScoreResult {
    // è¯„åˆ†ç®—æ³•å®ç°
  }
}
```

#### ç¬¬6-8å¤©: é«˜çº§åŠŸèƒ½
```typescript
// src/lib/generators/StructuredDataGenerator.ts
// src/lib/optimizers/ContentOptimizer.ts
// src/lib/competitors/CompetitorAnalyzer.ts
```

#### ç¬¬9-12å¤©: å‰ç«¯å¼€å‘
```typescript
// src/app/page.tsx - é¦–é¡µ
// src/app/analyze/page.tsx - åˆ†æå·¥ä½œå°
// src/app/dashboard/page.tsx - ç”¨æˆ·ä»ªè¡¨æ¿
// src/components/ui/* - å¯é‡ç”¨UIç»„ä»¶
```

### 7.3 è´¨é‡ä¿è¯æ£€æŸ¥æ¸…å•

```markdown
## GeoAIWork å¯åŠ¨æ£€æŸ¥æ¸…å•

### æŠ€æœ¯è´¨é‡
- [ ] æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æŒ‰è§„æ ¼å·¥ä½œ
- [ ] APIç«¯ç‚¹æµ‹è¯•å¹¶æ–‡æ¡£åŒ–
- [ ] è®¤è¯ç³»ç»Ÿå®‰å…¨ä¸”åŠŸèƒ½æ­£å¸¸
- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] å‰ç«¯åœ¨æ‰€æœ‰è®¾å¤‡å“åº”å¼
- [ ] æ€§èƒ½æŒ‡æ ‡è¾¾åˆ°ç›®æ ‡ï¼ˆ<5ç§’åˆ†ææ—¶é—´ï¼‰
- [ ] é”™è¯¯å¤„ç†å…¨é¢
- [ ] å®‰å…¨æœ€ä½³å®è·µå®æ–½

### ç”¨æˆ·ä½“éªŒ
- [ ] ç”¨æˆ·å¼•å¯¼æµç¨‹æµç•…
- [ ] åˆ†æç»“æœæ¸…æ™°å‘ˆç°
- [ ] æ–‡ä»¶ä¸‹è½½æ­£ç¡®å·¥ä½œ
- [ ] è®¢é˜…ç®¡ç†åŠŸèƒ½æ­£å¸¸
- [ ] å¸®åŠ©æ–‡æ¡£å®Œæ•´
- [ ] è”ç³»/æ”¯æŒç³»ç»Ÿå°±ç»ª

### ä¸šåŠ¡éœ€æ±‚
- [ ] å®šä»·æ–¹æ¡ˆæ­£ç¡®å®æ–½
- [ ] æ”¯ä»˜å¤„ç†å·¥ä½œï¼ˆStripeï¼‰
- [ ] ä½¿ç”¨è·Ÿè¸ªå’Œé…é¢ç³»ç»Ÿ
- [ ] åˆ†æå’Œç›‘æ§åˆ°ä½
- [ ] æ³•å¾‹é¡µé¢ï¼ˆéšç§ã€æ¡æ¬¾ï¼‰å°±ç»ª
- [ ] é‚®ä»¶é€šçŸ¥é…ç½®

### å¯åŠ¨å°±ç»ª
- [ ] åŸŸågeoaiwork.comé…ç½®
- [ ] SSLè¯ä¹¦å®‰è£…
- [ ] CDNå’Œæ€§èƒ½ä¼˜åŒ–
- [ ] å¤‡ä»½å’Œç¾éš¾æ¢å¤
- [ ] ç›‘æ§å’Œå‘Šè­¦è®¾ç½®
- [ ] å¯åŠ¨å…¬å‘Šææ–™å°±ç»ª
```

---

## 8. é£é™©è¯„ä¼°ä¸ç¼“è§£

### 8.1 æŠ€æœ¯é£é™©

| é£é™©é¡¹ç›® | æ¦‚ç‡ | å½±å“ | ç¼“è§£ç­–ç•¥ |
|-----------|-------------|--------|-------------------|
| ç½‘ç«™è¢«æŠ“å–é˜»æ­¢ | é«˜ | ä¸­ | å®æ–½å¤šç§æŠ“å–æ–¹æ³•ï¼Œéµå®ˆrobots.txtï¼Œç”¨æˆ·ä»£ç†è½®æ¢ |
| AI APIé™æµ | ä¸­ | ä¸­ | æœ¬åœ°ç®—æ³•å›é€€ï¼Œæ”¯æŒå¤šAIæä¾›å•† |
| æ•°æ®åº“æ€§èƒ½é—®é¢˜ | ä¸­ | é«˜ | æŸ¥è¯¢ä¼˜åŒ–ï¼Œé€‚å½“ç´¢å¼•ï¼Œç¼“å­˜å±‚ |
| ç¬¬ä¸‰æ–¹æœåŠ¡ä¾èµ– | ä½ | é«˜ | å¤šæä¾›å•†é€‰é¡¹ï¼Œä¼˜é›…é™çº§ |

### 8.2 ä¸šåŠ¡é£é™©

| é£é™©é¡¹ç›® | æ¦‚ç‡ | å½±å“ | ç¼“è§£ç­–ç•¥ |
|-----------|-------------|--------|-------------------|
| å¸‚åœºæ¥å—åº¦ä½ | ä¸­ | é«˜ | å¼ºåŠ›è¥é”€ï¼Œå…è´¹å±‚çº§ï¼Œç”¨æˆ·æ•™è‚² |
| ç«äº‰å¯¹æ‰‹å¿«é€Ÿè·Ÿéš | é«˜ | ä¸­ | æŒç»­åˆ›æ–°ï¼Œå…ˆå‘ä¼˜åŠ¿ |
| AIæœç´¢ç®—æ³•å˜åŒ– | ä¸­ | é«˜ | å…³æ³¨AIè¶‹åŠ¿ï¼Œçµæ´»æ¶æ„ |
| å®šä»·ç­–ç•¥ä¸åŒ¹é… | ä¸­ | ä¸­ | å¸‚åœºç ”ç©¶ï¼ŒA/Bæµ‹è¯•ï¼Œåé¦ˆæ”¶é›† |

### 8.3 è¿è¥é£é™©

| é£é™©é¡¹ç›® | æ¦‚ç‡ | å½±å“ | ç¼“è§£ç­–ç•¥ |
|-----------|-------------|--------|-------------------|
| æ‰©å±•æ€§æŒ‘æˆ˜ | ä¸­ | é«˜ | äº‘åŸç”Ÿæ¶æ„ï¼Œè‡ªåŠ¨æ‰©å±• |
| æ•°æ®éšç§åˆè§„ | ä½ | é«˜ | GDPRåˆè§„ï¼Œæ¸…æ™°éšç§æ”¿ç­– |
| å®¢æˆ·æ”¯æŒè´Ÿè½½ | ä¸­ | ä¸­ | è‡ªåŠ©æœåŠ¡æ–‡æ¡£ï¼ŒèŠå¤©æœºå™¨äººï¼Œåˆ†å±‚æ”¯æŒ |

---

## æ–‡æ¡£æ€»ç»“

æ­¤å…¨é¢çš„GeoAIWork.comäº§å“éœ€æ±‚æ–‡æ¡£æä¾›äº†ï¼š

### âœ… å®Œæ•´å¹³å°è®¾è®¡
1. **ä¸“ä¸šGEOåˆ†æå¼•æ“** - å…¨é¢çš„AIæœç´¢ä¼˜åŒ–åˆ†æ
2. **æ™ºèƒ½å†…å®¹ä¼˜åŒ–å™¨** - AIé©±åŠ¨çš„å†…å®¹ä¼˜åŒ–å»ºè®®
3. **è‡ªåŠ¨åŒ–èµ„æºç”Ÿæˆ** - FAQã€llm.txtã€ai-dataset.jsonæ–‡ä»¶ç”Ÿæˆ
4. **ç«äº‰å¯¹æ‰‹åˆ†æç³»ç»Ÿ** - æ·±åº¦ç«äº‰æƒ…æŠ¥å’ŒåŸºå‡†æµ‹è¯•

### ğŸ¯ æŠ€æœ¯å®æ–½æ–¹æ¡ˆ
1. **åŸºäºç°ä»£æŠ€æœ¯æ ˆ** - Next.js 15ã€TypeScriptã€Tailwind CSSã€PostgreSQL
2. **å®Œæ•´APIè§„æ ¼** - è¯¦ç»†æ¥å£è§„æ ¼å’Œæ•°æ®æ¨¡å‹
3. **ä¸“ä¸šUI/UXè®¾è®¡** - åˆ†æå·¥ä½œå°å’Œè¥é”€é¡µé¢
4. **å¯æ‰©å±•æ¶æ„** - æ”¯æŒæœªæ¥å¢é•¿å’ŒåŠŸèƒ½æ‰©å±•

### ğŸ“ˆ å•†ä¸šç­–ç•¥
1. **æ˜ç¡®ç›®æ ‡å¸‚åœº** - å›½é™…SEOä¸“ä¸šäººå£«ã€å†…å®¹åˆ›ä½œè€…ã€è¥é”€äººå‘˜
2. **å…è´¹å¢å€¼å•†ä¸šæ¨¡å¼** - å…è´¹å±‚çº§ä¸ä»˜è´¹å‡çº§
3. **ç«äº‰å®šä½** - GEOä¼˜åŒ–çš„å…ˆå‘ä¼˜åŠ¿
4. **å¢é•¿è·¯çº¿å›¾** - ä»MVPåˆ°å…¨åŠŸèƒ½å¹³å°

æ­¤PRDå·²å‡†å¤‡å¥½ç«‹å³å¼€å‘ï¼Œå¯æŒ‡å¯¼åˆ›å»ºGeoAIWork.comä½œä¸ºé¢†å…ˆçš„GEOä¼˜åŒ–å¹³å°ï¼ŒæœåŠ¡å…¨çƒå¸‚åœºã€‚